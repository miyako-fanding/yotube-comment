<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube 채널 댓글 추출기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 로딩 스피너 스타일 */
        .loader {
            border: 4px solid #f3f3f3;
            border-radius: 50%;
            border-top: 4px solid #3498db;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* 복사 기능을 위한 숨겨진 textarea */
        .hidden-textarea {
            position: absolute;
            left: -9999px;
            top: 0;
            opacity: 0;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="w-full max-w-2xl mx-auto bg-white rounded-2xl shadow-lg p-8 md:p-10">
        <div class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">YouTube 댓글 추출기</h1>
            <p class="text-gray-500 mt-2">채널의 최신 영상(Shorts 제외) 15개에서 모든 댓글을 추출하여 엑셀(CSV) 파일로 저장합니다.</p>
        </div>

        <!-- 입력 폼 -->
        <div class="space-y-6">
            <div>
                <label for="channelUrl" class="block text-sm font-medium text-gray-700 mb-1">YouTube 채널 URL</label>
                <input type="text" id="channelUrl" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="https://www.youtube.com/@ChannelHandle">
            </div>
        </div>

        <!-- 확인용 체크박스 -->
        <div class="mt-6 flex items-center justify-center">
            <input id="confirmCheckbox" type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded">
            <label for="confirmCheckbox" class="ml-2 flex items-center text-sm text-gray-900 select-none cursor-pointer">
                팬딩이와 LS팀의 무궁한 발전을 믿으시나요?
                <img src="https://raw.githubusercontent.com/miyako-fanding/image-storage/main/%ED%8C%AC%EB%94%A9%EC%9D%B4(%EB%88%84%EB%81%BC).png" alt="팬딩이" class="h-10 w-10 ml-2">
            </label>
        </div>
        
        <!-- 프롬프트 복사 섹션 -->
        <div class="mt-4 p-4 bg-gray-50 rounded-lg text-center border border-gray-200">
            <div class="flex items-center justify-center">
                 <a href="https://gemini.google.com" target="_blank" class="text-sm text-blue-600 hover:underline font-medium">gemini</a>에 붙여넣을 분석 프롬프트 복사하기
                 <button id="copyPromptButton" class="ml-4 bg-gray-200 text-gray-800 text-xs font-bold py-1 px-3 rounded-md hover:bg-gray-300 transition-all">복사</button>
            </div>
        </div>

        <!-- 실행 버튼 -->
        <div class="mt-8">
            <button id="startButton" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 flex items-center justify-center disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                <span id="buttonText">댓글 추출 시작</span>
                <div id="loader" class="loader hidden ml-3"></div>
            </button>
        </div>

        <!-- 상태 메시지 및 다운로드 버튼 -->
        <div id="status" class="mt-6 text-center text-gray-600 h-12"></div>
        <div class="mt-4 text-center">
            <button id="downloadButton" class="hidden bg-green-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-200">
                엑셀 파일(CSV) 다운로드
            </button>
        </div>
    </div>

    <!-- 복사를 위한 프롬프트 텍스트 -->
    <textarea id="promptText" class="hidden-textarea" readonly>
[프롬프트] 유튜브 댓글 기반 고객 니즈 분석 및 멤버십 제안 프롬프트 (v2.0)
[ROLE]
당신은 최고의 CRM(고객 관계 관리) 및 데이터 분석 전문가입니다. 고객의 목소리에서 핵심 니즈를 파악하고, 이를 바탕으로 성공적인 비즈니스 전략을 제안하는 능력이 탁월합니다.
[OBJECTIVE]
유튜브 크리에이터에게 새로운 멤버십 비즈니스 및 강의 커리큘럼을 제안하는 것을 목표로 합니다. 우리의 제안이 단순한 감이 아닌, 채널 구독자들의 실제 데이터에 기반한 것임을 입증하여 제안의 설득력을 극대화해야 합니다.
[CONTEXT]
첨부된 파일은 특정 유튜브 채널의 영상 댓글 데이터입니다. 이 댓글들을 분석하여 구독자들이 가장 빈번하고 절실하게 호소하는 문제점과 니즈가 무엇인지 파악해야 합니다. 이 분석 결과는 제안서의 핵심 근거 자료로 사용될 것입니다.
[INPUT DATA]
유튜브 영상의 댓글 데이터가 포함된 CSV 또는 엑셀 파일.
파일에는 '작성자'와 '내용' 컬럼이 포함되어 있습니다.
[CORE TASK]
첨부된 댓글 데이터에서 오직 구독자(시청자)의 댓글만을 분석하여, 아래 명시된 형식에 따라 '고객 니즈 분석 매트릭스'를 작성해 주세요.
⭐ [중요 분석 조건] ⭐
유튜버(채널 운영자)의 댓글 제외: 데이터의 정확성을 위해, 유튜버가 직접 작성한 댓글이나 구독자 질문에 답변하는 대댓글은 반드시 분석 대상에서 제외해야 합니다. 분석은 구독자의 순수한 니즈 파악에만 집중합니다. '작성자' 컬럼을 기준으로 채널 운영자의 아이디를 식별하고, 해당 작성자의 모든 활동을 집계에서 제외하세요.
[OUTPUT FORMAT]
1. 제목: 고객 니즈 분석 매트릭스
2. 매트릭스 테이블: 아래 5개의 컬럼을 반드시 포함하여 표 형식으로 작성해 주세요.
| 빈도 순위 | 핵심 문제/콘텐츠 요청 | 빈도수 (건수/%) | 대표 댓글 인용 | 내재된 니즈 |
| :--- | :--- | :--- | :--- | :--- |
3. 분석 결과 및 제안: 매트릭스 작성 후, 분석 결과를 요약하고 이를 바탕으로 제안할 수 있는 멤버십 혜택과 강의 커리큘럼 아이디어를 2~3가지 구체적으로 제시해 주세요.
[STEP-BY-STEP INSTRUCTIONS]
1. 데이터 필터링: '작성자' 컬럼을 확인하여 유튜버(채널 운영자)의 아이디를 먼저 파악합니다. 그 후, 유튜버가 작성한 모든 댓글과 대댓글을 분석 대상에서 완전히 제외합니다. 이후의 모든 분석은 필터링된, 즉 순수 구독자의 댓글만을 대상으로 진행합니다.
2. 데이터 분석: 필터링된 구독자 댓글 데이터를 전체적으로 분석하여, 구독자들이 주로 언급하는 피부 고민, 질문, 요청사항 등의 핵심 키워드와 주제를 파악합니다.
3. 카테고리화: 파악된 주제들을 의미 있는 단위로 그룹화하여 '핵심 문제/콘텐츠 요청' 카테고리를 생성합니다. (예: 여드름/트러블, 모공/블랙헤드, 제품 추천 요청 등)
4. 빈도수 계산: 각 카테고리에 해당하는 댓글의 **총 개수(건수)**와 전체 댓글에서 차지하는 **비율(%)**을 계산합니다.
5. 순위 결정: 계산된 빈도수를 기준으로 가장 많이 언급된 순서대로 '빈도 순위'를 매깁니다.
6. 대표 댓글 선정: 각 카테고리의 특징과 문제점을 가장 잘 보여주는 실제 구독자 댓글을 하나씩 선정하여 '대표 댓글 인용' 항목에 기입합니다.
7. 내재된 니즈 추론: 각 카테고리의 댓글에 담긴 표면적인 질문을 넘어, 구독자들이 근본적으로 원하는 것이 무엇인지(예: 시간/비용 절약, 불안감 해소, 자기효능감 획득 등)를 추론하여 '내재된 니즈' 항목에 작성합니다.
8. 결과물 생성: 위의 단계에서 도출된 내용을 종합하여 최종 '고객 니즈 분석 매트릭스'를 완성하고, 그 후에 '분석 결과 및 제안'을 논리적으로 서술합니다.
[TONE & STYLE]
- 전문가적이고 신뢰감을 주는 톤
- 데이터에 기반한 객관적인 사실을 전달
- 제안 부분은 설득력 있고 실행 가능한 아이디어로 구성
    </textarea>

    <script type="module">
        // UI 요소 가져오기
        const channelUrlInput = document.getElementById('channelUrl');
        const confirmCheckbox = document.getElementById('confirmCheckbox');
        const startButton = document.getElementById('startButton');
        const downloadButton = document.getElementById('downloadButton');
        const statusDiv = document.getElementById('status');
        const loader = document.getElementById('loader');
        const buttonText = document.getElementById('buttonText');
        const copyPromptButton = document.getElementById('copyPromptButton');
        const promptTextarea = document.getElementById('promptText');

        // API 키를 여기에 직접 설정합니다.
        const API_KEY = 'AIzaSyCVJd0ydKfUito4NczSvHDzl23352QjuIQ';

        let allCommentsData = [];

        // 체크박스 변경 이벤트: 체크해야 버튼 활성화
        confirmCheckbox.addEventListener('change', () => {
            startButton.disabled = !confirmCheckbox.checked;
        });

        // 프롬프트 복사 버튼 클릭 이벤트
        copyPromptButton.addEventListener('click', () => {
            promptTextarea.select();
            promptTextarea.setSelectionRange(0, 99999); 
            try {
                document.execCommand('copy');
                copyPromptButton.textContent = '복사 완료!';
                setTimeout(() => {
                    copyPromptButton.textContent = '복사';
                }, 2000);
            } catch (err) {
                console.error('클립보드 복사에 실패했습니다:', err);
                alert('프롬프트 복사에 실패했습니다.');
            }
            window.getSelection().removeAllRanges();
        });

        // 시작 버튼 클릭 이벤트
        startButton.addEventListener('click', async () => {
            const channelUrl = channelUrlInput.value.trim();

            if (!channelUrl) {
                updateStatus('채널 URL을 입력해주세요.', 'error');
                return;
            }

            resetUI();
            setLoading(true);

            try {
                updateStatus('1/5: 채널 정보 조회 중...');
                const channelId = await getChannelId(API_KEY, channelUrl);
                if (!channelId) {
                    throw new Error('유효한 채널 ID를 찾을 수 없습니다. 채널 URL을 확인해주세요.');
                }

                updateStatus('2/5: 업로드 목록 조회 중...');
                const uploadsPlaylistId = await getUploadsPlaylistId(API_KEY, channelId);

                updateStatus('3/5: 최신 동영상 15개 찾는 중...');
                const videoIds = await getVideoIds(API_KEY, uploadsPlaylistId);
                
                if (videoIds.length === 0) {
                    throw new Error('분석할 일반 영상이 없습니다. (Shorts 제외)');
                }

                for (let i = 0; i < videoIds.length; i++) {
                    updateStatus(`4/5: 댓글 수집 중... (영상 ${i + 1}/${videoIds.length})`);
                    const comments = await getCommentsForVideo(API_KEY, videoIds[i].id, videoIds[i].title);
                    allCommentsData.push(...comments);
                }

                updateStatus(`5/5: 총 ${allCommentsData.length}개의 댓글 수집 완료!`, 'success');
                downloadButton.classList.remove('hidden');

            } catch (error) {
                console.error('Error:', error);
                updateStatus(`오류 발생: ${error.message}`, 'error');
            } finally {
                setLoading(false);
            }
        });

        downloadButton.addEventListener('click', () => {
            if (allCommentsData.length > 0) {
                downloadCSV(allCommentsData);
            }
        });

        function resetUI() {
            allCommentsData = [];
            downloadButton.classList.add('hidden');
            statusDiv.innerHTML = '';
        }

        function setLoading(isLoading) {
            if (isLoading) {
                startButton.disabled = true;
                loader.classList.remove('hidden');
                buttonText.textContent = '추출 중...';
            } else {
                startButton.disabled = !confirmCheckbox.checked;
                loader.classList.add('hidden');
                buttonText.textContent = '댓글 추출 시작';
            }
        }
        
        function parseChannelUrl(url) {
            try {
                const path = new URL(url).pathname.split('/').filter(p => p);
                if (path[0] === 'channel') return { channelId: path[1] };
                if (path[0] === 'c' || path[0] === 'user') return { forUsername: path[1] };
                if (path[0].startsWith('@')) return { forHandle: path[0] };
                return {};
            } catch (e) {
                if(url.startsWith('UC')) return { channelId: url };
                if(url.startsWith('@')) return { forHandle: url };
                return { forUsername: url };
            }
        }

        async function getChannelId(apiKey, channelUrl) {
            const { channelId, forUsername, forHandle } = parseChannelUrl(channelUrl);
            if (channelId) return channelId;

            let searchParams = '';
            if (forUsername) {
                searchParams = `forUsername=${encodeURIComponent(forUsername)}`;
            } else if (forHandle) {
                 searchParams = `forHandle=${encodeURIComponent(forHandle.substring(1))}`;
            } else {
                return null;
            }
            
            const url = `https://www.googleapis.com/youtube/v3/channels?part=id&${searchParams}&key=${apiKey}`;
            const response = await fetch(url);
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                return data.items[0].id;
            }
            return null;
        }

        async function getUploadsPlaylistId(apiKey, channelId) {
            const url = `https://www.googleapis.com/youtube/v3/channels?part=contentDetails&id=${channelId}&key=${apiKey}`;
            const response = await fetch(url);
            const data = await response.json();
            return data.items[0].contentDetails.relatedPlaylists.uploads;
        }

        // *** Shorts 영상을 제외하도록 수정된 함수 ***
        async function getVideoIds(apiKey, playlistId) {
            // 필터링을 위해 충분한 수의 영상을 가져옵니다 (최대 50개).
            const url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&playlistId=${playlistId}&maxResults=50&key=${apiKey}`;
            const response = await fetch(url);
            const data = await response.json();

            if (!data.items) {
                return []; // 아이템이 없으면 빈 배열 반환
            }

            // 제목에 '#shorts'가 포함되지 않은 영상만 필터링합니다.
            const nonShortsVideos = data.items.filter(item => 
                !item.snippet.title.toLowerCase().includes('#shorts')
            );

            // 필터링된 영상 중에서 최신 15개를 선택합니다.
            const latestVideos = nonShortsVideos.slice(0, 15);

            return latestVideos.map(item => ({
                id: item.snippet.resourceId.videoId,
                title: item.snippet.title
            }));
        }

        async function getCommentsForVideo(apiKey, videoId, videoTitle) {
            let comments = [];
            let nextPageToken = '';
            const baseUrl = `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet,replies&videoId=${videoId}&key=${apiKey}&maxResults=100`;

            do {
                const url = nextPageToken ? `${baseUrl}&pageToken=${nextPageToken}` : baseUrl;
                const response = await fetch(url);
                const data = await response.json();

                if (data.items) {
                    for (const item of data.items) {
                        const topLevelComment = item.snippet.topLevelComment.snippet;
                        comments.push({
                            videoTitle: videoTitle,
                            author: topLevelComment.authorDisplayName,
                            comment: topLevelComment.textOriginal,
                            publishedAt: new Date(topLevelComment.publishedAt).toLocaleString('ko-KR'),
                            likeCount: topLevelComment.likeCount,
                            isReply: '아니오',
                            replyTo: ''
                        });
                        
                        if (item.replies) {
                            for (const reply of item.replies.comments) {
                                const replySnippet = reply.snippet;
                                comments.push({
                                    videoTitle: videoTitle,
                                    author: replySnippet.authorDisplayName,
                                    comment: replySnippet.textOriginal,
                                    publishedAt: new Date(replySnippet.publishedAt).toLocaleString('ko-KR'),
                                    likeCount: replySnippet.likeCount,
                                    isReply: '예',
                                    replyTo: topLevelComment.authorDisplayName
                                });
                            }
                        }
                    }
                }
                nextPageToken = data.nextPageToken;
            } while (nextPageToken);

            return comments;
        }

        function updateStatus(message, type = 'info') {
            statusDiv.textContent = message;
            if (type === 'success') {
                statusDiv.className = 'mt-6 text-center text-green-600 font-semibold h-12';
            } else if (type === 'error') {
                statusDiv.className = 'mt-6 text-center text-red-600 font-semibold h-12';
            } else {
                statusDiv.className = 'mt-6 text-center text-gray-600 h-12';
            }
        }

        function downloadCSV(data) {
            const headers = ['영상 제목', '작성자', '댓글 내용', '작성일', '좋아요 수', '답글 여부', '답글 대상'];
            const csvContent = [
                headers.join(','),
                ...data.map(row => [
                    `"${row.videoTitle.replace(/"/g, '""')}"`,
                    `"${row.author.replace(/"/g, '""')}"`,
                    `"${row.comment.replace(/"/g, '""')}"`,
                    row.publishedAt,
                    row.likeCount,
                    row.isReply,
                    `"${row.replyTo.replace(/"/g, '""')}"`
                ].join(','))
            ].join('\n');

            const BOM = '\uFEFF';
            const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
            
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                const channelName = channelUrlInput.value.split('/').pop();
                link.setAttribute('href', url);
                link.setAttribute('download', `youtube_comments_${channelName}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    </script>
</body>
</html>
